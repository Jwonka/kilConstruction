---
import AdminLayout from "../../layout/AdminLayout.astro";
import "../../styles/global.css";
import "../../styles/admin.css";

const cookies = Astro.cookies;
const auth = cookies.get("admin_auth")?.value || "";

// Cloudflare runtime env
const env = (Astro.locals as any).runtime?.env ?? {};
const ADMIN_SECRET = env.ADMIN_SECRET;

// build-time public API URL for the worker
const PUBLIC_GALLERY_API = import.meta.env.PUBLIC_GALLERY_API || "https://kilcon.work/api/gallery-api";

const ADMIN_API_BASE = import.meta.env.DEV
    ? PUBLIC_GALLERY_API          // dev → hit remote worker
    : "/api/gallery-api";

if (!ADMIN_SECRET || auth !== ADMIN_SECRET) {
    return new Response(null, {
        status: 302,
        headers: { Location: "/admin" },
    });
}
---
<AdminLayout title="Manage Images">
    <h1 class="admin-title">Manage Images</h1>
    <p class="admin-subtitle">
        Browse and search existing folders from the R2 gallery bucket.
        Expand a folder to see its files and select items to delete.
    </p>

    <section class="panel">
        <div class="toolbar">
            <label for="search"></label><input
                    id="search"
                    type="search"
                    placeholder="Search by folder or file name…"
                    class="search-input"
            />
            <div class="toolbar-actions">
                <button id="refresh" type="button" class="btn-small">
                    Refresh
                </button>
                <button id="bulk-delete" type="button" class="btn-small btn-danger">
                    Delete selected
                </button>
            </div>
        </div>

        <div id="status" class="status-row">Loading projects…</div>

        <ul id="results" class="results-list" data-public-api={PUBLIC_GALLERY_API} data-admin-api={ADMIN_API_BASE}></ul>
    </section>

    <script>
        // @ts-nocheck
        document.addEventListener("DOMContentLoaded", () => {
            const listEl = document.getElementById("results");
            const statusEl = document.getElementById("status");
            const searchEl = document.getElementById("search");
            const refreshEl = document.getElementById("refresh");
            const bulkDeleteEl = document.getElementById("bulk-delete");

            if (!listEl || !statusEl || !searchEl || !refreshEl || !bulkDeleteEl) {
                console.error("[manage] Missing one or more DOM elements");
                return;
            }

            const publicApiBase = (listEl.dataset.publicApi || "").replace(/\/$/, "");
            const adminApiBase = (listEl.dataset.adminApi || "").replace(/\/$/, "");

            if (!publicApiBase || !adminApiBase) {
                statusEl.textContent = "Missing gallery API URL.";
                return;
            }

            /** @type {{ slug: string; name?: string }[]} */
            let allProjects = [];
            /** @type {Set<string>} */
            const expandedPrefixes = new Set();

            async function loadProjects() {
                try {
                    statusEl.textContent = "Loading projects…";
                    listEl.innerHTML = "";

                    const res = await fetch(`${publicApiBase}?all=1`, {
                        credentials: "include",
                        });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);

                    const data = await res.json();
                    allProjects = (data.projects || []);

                    statusEl.textContent = `Loaded ${allProjects.length} folders.`;
                    renderProjects();
                } catch (err) {
                    console.error(err);
                    statusEl.textContent = "Error loading projects.";
                }
            }

            function renderProjects() {
                const q = searchEl.value.trim().toLowerCase();
                listEl.innerHTML = "";

                const items = allProjects.filter((p) => {
                    if (!q) return true;
                    const name = (p.name || "").toLowerCase();
                    const slug = (p.slug || "").toLowerCase();
                    return name.includes(q) || slug.includes(q);
                });

                if (!items.length) {
                    listEl.innerHTML =
                        '<li class="empty">No folders match that search.</li>';
                    return;
                }

                for (const p of items) {
                    const li = document.createElement("li");
                    li.className = "result-item";

                    const rawPrefix = p.prefix || decodeURIComponent(p.slug || "");
                    const prefix = rawPrefix.endsWith("/") ? rawPrefix : rawPrefix + "/"; // e.g. "Furniture/Cabinets/"
                    li.dataset.prefix = prefix;

                    // ---- header row ----
                    const header = document.createElement("div");
                    header.className = "item-header";

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "select-checkbox";
                    checkbox.dataset.type = "project";
                    checkbox.dataset.prefix = prefix;

                    const expandBtn = document.createElement("button");
                    expandBtn.type = "button";
                    expandBtn.className = "expand-btn";
                    expandBtn.textContent = expandedPrefixes.has(prefix) ? "▾" : "▸";
                    expandBtn.dataset.prefix = prefix;

                    const textWrap = document.createElement("div");
                    textWrap.className = "item-text";

                    // Show full directory path as the *only* label, e.g. "Furniture/Cabinets"
                    const title = document.createElement("div");
                    title.className = "result-title";
                    title.textContent = prefix.replace(/\/$/, "") || "(unnamed)";

                    textWrap.appendChild(title);

                    // Order: [checkbox] [caret] [Folder path]
                    // Visual order: [caret] [Folder path] [checkbox]
                    header.appendChild(expandBtn);
                    header.appendChild(textWrap);
                    header.appendChild(checkbox);

                    li.appendChild(header);

                    // ---- children container (files) ----
                    const children = document.createElement("ul");
                    children.className = "children-list";
                    children.dataset.prefix = prefix;
                    if (!expandedPrefixes.has(prefix)) {
                        children.style.display = "none";
                    }

                    li.appendChild(children);
                    listEl.appendChild(li);
                }
            }

            async function loadFolderFiles(childrenEl, prefix) {
                if (!childrenEl || !prefix) return;

                childrenEl.dataset.prefix = prefix.endsWith("/") ? prefix : prefix + "/";
                childrenEl.dataset.loaded = "0";
                childrenEl.innerHTML = `<li class="empty">Loading files…</li>`;

                try {
                    const res = await fetch(
                        `${adminApiBase}/list-images?` + new URLSearchParams({ prefix }),
                        { method: "GET",credentials: "include" }
                    );
                    /** @type {{ objects?: any[] }} */
                    const data = await res.json().catch(() => ({}));

                    childrenEl.innerHTML = "";

                    if (Array.isArray(data.objects) && data.objects.length) {
                        renderFiles(childrenEl, data.objects);
                        childrenEl.dataset.loaded = "1";
                    } else {
                        childrenEl.innerHTML = `<li class="empty">No image files found.</li>`;
                    }
                } catch (err) {
                    console.error("loadFolderFiles error", err);
                    childrenEl.innerHTML = `<li class="empty">Error loading files.</li>`;
                }
            }

            async function toggleFolder(prefix, li) {
                const children = li.querySelector(".children-list");
                const expandBtn = li.querySelector(".expand-btn");
                if (!children || !expandBtn) return;

                const isExpanded = expandedPrefixes.has(prefix);
                if (isExpanded) {
                    expandedPrefixes.delete(prefix);
                    children.style.display = "none";
                    expandBtn.textContent = "▸";
                    return;
                }

                expandedPrefixes.add(prefix);
                children.style.display = "block";
                expandBtn.textContent = "▾";

                if (children.dataset.loaded !== "1") {
                    // REPLACE previous fetch block with:
                    await loadFolderFiles(children, prefix);
                }

                if (children.dataset.loaded === "1") {
                    return;
                }

                children.innerHTML =
                    '<li class="status-row child-status">Loading files…</li>';

                try {
                    const url = `${adminApiBase}/list-images?prefix=${encodeURIComponent(prefix)}`;
                    const res = await fetch(url, { credentials: "include" });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);

                    const data = await res.json();
                    console.log("list-images response for", prefix, data);

                    // Try several common shapes, fall back to [].
                    let rawList =
                        (Array.isArray(data.objects) && data.objects) ||
                        (Array.isArray(data.items) && data.items) ||
                        (Array.isArray(data.files) && data.files) ||
                        [];

                    // Normalise to { key, size, uploaded, name }
                    const objects = rawList.map((obj) => {
                        const key = obj.key || obj.name || "";
                        const name =
                            obj.name || (key ? key.split("/").pop() : "(unnamed)");
                        return {
                            key,
                            name,
                            size: obj.size || obj.bytes || 0,
                            uploaded: obj.uploaded || obj.uploadedAt || obj.created || null,
                        };
                    });

                    renderFiles(children, objects);
                    children.dataset.loaded = "1";
                } catch (err) {
                    console.error(err);
                    children.innerHTML =
                        '<li class="status-row child-status">Error loading files.</li>';
                }
            }

            function renderFiles(container, objects) {
                container.innerHTML = "";

                if (!objects.length) {
                    const li = document.createElement("li");
                    li.className = "child-item empty";
                    li.textContent = "No files in this folder.";
                    container.appendChild(li);
                    return;
                }

                for (const obj of objects) {
                    const li = document.createElement("li");
                    li.className = "child-item";
                    li.dataset.key = obj.key;

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "select-checkbox";
                    checkbox.dataset.type = "file";
                    checkbox.dataset.key = obj.key;

                    const info = document.createElement("div");
                    info.className = "child-info";

                    const nameWrapper = document.createElement("div");
                    nameWrapper.className = "rename-wrapper";

                    const nameDisplay = document.createElement("span");
                    nameDisplay.className = "name-display";
                    nameDisplay.textContent = obj.name;

                    const nameInput = document.createElement("input");
                    nameInput.type = "text";
                    nameInput.className = "rename-input";
                    nameInput.value = obj.name;
                    nameInput.style.display = "none";

                    nameWrapper.appendChild(nameDisplay);
                    nameWrapper.appendChild(nameInput);

                    const metaEl = document.createElement("div");
                    metaEl.className = "image-meta";
                    const sizeKB = obj.size
                        ? (obj.size / 1024).toFixed(1) + " KB"
                        : "";
                    const when = obj.uploaded
                        ? new Date(obj.uploaded).toLocaleString()
                        : "";
                    const metaParts: string[] = [];
                    if (sizeKB) metaParts.push(sizeKB);
                    if (when) metaParts.push(when);

                    // size and date on separate lines
                    metaEl.innerHTML = metaParts.join("<br>");

                    info.appendChild(nameWrapper);
                    info.appendChild(metaEl);

                    li.appendChild(info);
                    li.appendChild(checkbox);
                    container.appendChild(li);

                    // --- Rename handlers
                    function resetRename() {
                        nameDisplay.style.display = "inline-block";
                        nameInput.style.display = "none";
                        delete title.dataset.renameActive;
                    }

                    async function commitRename() {
                        const newName = nameInput.value.trim();
                        if (!newName || newName === obj.name) {
                            resetRename();
                            return;
                        }

                        const folder = obj.key.split("/").slice(0, -1).join("/");
                        const newKey = folder + "/" + newName;
                        try {
                            const res = await fetch(`${adminApiBase}/rename`, {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ oldKey: obj.key, newKey }),
                                credentials: "include",
                            });

                            if (res.ok) {
                                obj.name = newName;
                                obj.key = newKey;
                                nameDisplay.textContent = newName;

                                const row = li;
                                row.classList.add("just-renamed");

                                setTimeout(() => {
                                    row.classList.remove("just-renamed");
                                }, 1200);

                                const children = row.closest("ul.children-list");
                                if (children && folder) {
                                    await loadFolderFiles(children, folder + "/");
                                }
                                alert("Renamed successfully.");
                            } else {
                                alert("Rename failed");
                            }
                        } catch (err) {
                            console.error("Rename error", err);
                            alert("Rename failed");
                        }
                        resetRename();
                    }

                    nameDisplay.addEventListener("click", () => {
                        nameDisplay.style.display = "none";
                        nameInput.style.display = "inline-block";
                        nameInput.focus();
                    });

                    nameInput.addEventListener("blur", commitRename);
                    nameInput.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") commitRename();
                        if (e.key === "Escape") resetRename();
                    });

                }
            }

            // search / refresh
            searchEl.addEventListener("input", () => {
                renderProjects();
            });

            refreshEl.addEventListener("click", () => {
                expandedPrefixes.clear();
                loadProjects();
            });

            // folder expand / collapse
            listEl.addEventListener("click", async (event) => {
                const target = event.target;
                if (!target) return;

                const expandBtn = target.closest(".expand-btn");
                if (expandBtn && expandBtn.dataset.prefix) {
                    const prefix = expandBtn.dataset.prefix;
                    const row = expandBtn.closest(".result-item");
                    if (!row) return;
                    await toggleFolder(prefix, row);
                }
            });

            // bulk delete
            bulkDeleteEl.addEventListener("click", async () => {
                /** @type {HTMLInputElement[]} */
                const checked = Array.from(
                    listEl.querySelectorAll(".select-checkbox:checked")
                );

                if (!checked.length) {
                    alert("No items selected.");
                    return;
                }

                const projectPrefixes = [];
                const fileKeys = [];

                for (const input of checked) {
                    if (input.dataset.type === "project" && input.dataset.prefix) {
                        projectPrefixes.push(input.dataset.prefix);
                    } else if (input.dataset.type === "file" && input.dataset.key) {
                        fileKeys.push(input.dataset.key);
                    }
                }

                if (!projectPrefixes.length && !fileKeys.length) {
                    alert("No valid items selected.");
                    return;
                }

                const confirmMsg = [
                    projectPrefixes.length
                        ? `Projects: ${projectPrefixes.length}`
                        : null,
                    fileKeys.length ? `Files: ${fileKeys.length}` : null,
                    "",
                    "This cannot be undone.",
                ]
                    .filter(Boolean)
                    .join("\n");

                if (!confirm(confirmMsg)) return;

                bulkDeleteEl.disabled = true;
                const originalText = bulkDeleteEl.textContent || "Delete selected";
                bulkDeleteEl.textContent = "Deleting…";

                try {
                    // delete projects
                    for (const prefix of projectPrefixes) {
                        try {
                            const res = await fetch(`${adminApiBase}/delete-project`, {
                                method: "POST",
                                headers: { "content-type": "application/json" },
                                body: JSON.stringify({ prefix }),
                                credentials: "include",
                            });
                            if (!res.ok) {
                                console.error("Project delete failed for", prefix, res.status);
                            }
                        } catch (err) {
                            console.error("Project delete error for", prefix, err);
                        }
                    }

                    // delete files
                    for (const key of fileKeys) {
                        try {
                            const res = await fetch(`${adminApiBase}/delete`, {
                                method: "POST",
                                headers: { "content-type": "application/json" },
                                body: JSON.stringify({ key }),
                                credentials: "include",
                            });
                            if (!res.ok) {
                                console.error("File delete failed for", key, res.status);
                            }
                        } catch (err) {
                            console.error("File delete error for", key, err);
                        }
                    }

                    // reload everything so UI matches bucket state
                    expandedPrefixes.clear();
                    await loadProjects();
                    alert("Delete finished. Some failures (if any) are logged in console.");
                } finally {
                    bulkDeleteEl.disabled = false;
                    bulkDeleteEl.textContent = originalText;
                }
            });
            loadProjects();
        });
    </script>
</AdminLayout>
