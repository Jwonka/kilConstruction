---
import AdminLayout from "../../layout/AdminLayout.astro";

const cookies = Astro.cookies;
const auth = cookies.get("admin_auth")?.value || "";

// Cloudflare runtime env
const env = (Astro.locals as any).runtime?.env ?? {};
const ADMIN_SECRET = env.ADMIN_SECRET;
const GALLERY_API = env.PUBLIC_GALLERY_API;

if (!ADMIN_SECRET || auth !== ADMIN_SECRET) {
    return new Response(null, {
        status: 302,
        headers: { Location: "/admin" },
    });
}
---
<AdminLayout title="Manage Uploaded Files">
    <h1 class="admin-title">Manage Uploaded Files</h1>
    <p class="admin-subtitle">
        Browse and search existing folders from the R2 gallery bucket.
        Expand a folder to see its files and select items to delete.
    </p>

    <section class="panel">
        <div class="toolbar">
            <label for="search"></label><input
                    id="search"
                    type="search"
                    placeholder="Search by folder or file name…"
                    class="search-input"
            />
            <div class="toolbar-actions">
                <button id="refresh" type="button" class="btn-small">
                    Refresh
                </button>
                <button id="bulk-delete" type="button" class="btn-small btn-danger">
                    Delete selected
                </button>
            </div>
        </div>

        <div id="status" class="status-row">Loading projects…</div>

        <ul id="results" class="results-list" data-api={GALLERY_API}></ul>
    </section>

    <script>
        // @ts-nocheck
        document.addEventListener("DOMContentLoaded", () => {
            const listEl = document.getElementById("results");
            const statusEl = document.getElementById("status");
            const searchEl = document.getElementById("search");
            const refreshEl = document.getElementById("refresh");
            const bulkDeleteEl = document.getElementById("bulk-delete");

            if (!listEl || !statusEl || !searchEl || !refreshEl || !bulkDeleteEl) {
                console.error("[admin/manage] Missing one or more DOM elements");
                return;
            }

            const api = listEl.dataset.api ?? "";
            if (!api) {
                statusEl.textContent = "Missing gallery API URL.";
                return;
            }
            const apiBase = api.replace(/\/$/, "");

            /** @type {{ slug: string; name?: string }[]} */
            let allProjects = [];
            /** @type {Set<string>} */
            const expandedPrefixes = new Set();

            async function loadProjects() {
                try {
                    statusEl.textContent = "Loading projects…";
                    listEl.innerHTML = "";

                    const res = await fetch(`${api}?all=1`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);

                    const data = await res.json();
                    allProjects = (data.projects || []);

                    statusEl.textContent = `Loaded ${allProjects.length} folders.`;
                    renderProjects();
                } catch (err) {
                    console.error(err);
                    statusEl.textContent = "Error loading projects.";
                }
            }

            function renderProjects() {
                const q = searchEl.value.trim().toLowerCase();
                listEl.innerHTML = "";

                const items = allProjects.filter((p) => {
                    if (!q) return true;
                    const name = (p.name || "").toLowerCase();
                    const slug = (p.slug || "").toLowerCase();
                    return name.includes(q) || slug.includes(q);
                });

                if (!items.length) {
                    listEl.innerHTML =
                        '<li class="empty">No folders match that search.</li>';
                    return;
                }

                for (const p of items) {
                    const li = document.createElement("li");
                    li.className = "result-item";

                    const rawPrefix = p.prefix || decodeURIComponent(p.slug || "");
                    const prefix = rawPrefix.endsWith("/") ? rawPrefix : rawPrefix + "/"; // e.g. "Furniture/Cabinets/"
                    li.dataset.prefix = prefix;

                    // ---- header row ----
                    const header = document.createElement("div");
                    header.className = "item-header";

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "select-checkbox";
                    checkbox.dataset.type = "project";
                    checkbox.dataset.prefix = prefix;

                    const expandBtn = document.createElement("button");
                    expandBtn.type = "button";
                    expandBtn.className = "expand-btn";
                    expandBtn.textContent = expandedPrefixes.has(prefix) ? "▾" : "▸";
                    expandBtn.dataset.prefix = prefix;

                    const textWrap = document.createElement("div");
                    textWrap.className = "item-text";

                    // Show full directory path as the *only* label, e.g. "Furniture/Cabinets"
                    const title = document.createElement("div");
                    title.className = "result-title";
                    title.textContent = prefix.replace(/\/$/, "") || "(unnamed)";

                    textWrap.appendChild(title);

                    // Order: [checkbox] [caret] [Folder path]
                    // Visual order: [caret] [Folder path] [checkbox]
                    header.appendChild(expandBtn);
                    header.appendChild(textWrap);
                    header.appendChild(checkbox);

                    li.appendChild(header);

                    // ---- children container (files) ----
                    const children = document.createElement("ul");
                    children.className = "children-list";
                    children.dataset.prefix = prefix;
                    if (!expandedPrefixes.has(prefix)) {
                        children.style.display = "none";
                    }

                    li.appendChild(children);
                    listEl.appendChild(li);
                }
            }

            async function toggleFolder(prefix, li) {
                const children = li.querySelector(".children-list");
                const expandBtn = li.querySelector(".expand-btn");
                if (!children || !expandBtn) return;

                const isExpanded = expandedPrefixes.has(prefix);
                if (isExpanded) {
                    expandedPrefixes.delete(prefix);
                    children.style.display = "none";
                    expandBtn.textContent = "▸";
                    return;
                }

                expandedPrefixes.add(prefix);
                children.style.display = "block";
                expandBtn.textContent = "▾";

                if (children.dataset.loaded === "1") {
                    return;
                }

                children.innerHTML =
                    '<li class="status-row child-status">Loading files…</li>';

                try {
                    const url = `${apiBase}/list-images?prefix=${encodeURIComponent(prefix)}`;
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);

                    const data = await res.json();
                    console.log("list-images response for", prefix, data);

                    // Try several common shapes, fall back to [].
                    let rawList =
                        (Array.isArray(data.objects) && data.objects) ||
                        (Array.isArray(data.items) && data.items) ||
                        (Array.isArray(data.files) && data.files) ||
                        [];

                    // Normalise to { key, size, uploaded, name }
                    const objects = rawList.map((obj) => {
                        const key = obj.key || obj.name || "";
                        const name =
                            obj.name || (key ? key.split("/").pop() : "(unnamed)");
                        return {
                            key,
                            name,
                            size: obj.size || obj.bytes || 0,
                            uploaded: obj.uploaded || obj.uploadedAt || obj.created || null,
                        };
                    });

                    renderFiles(children, objects);
                    children.dataset.loaded = "1";
                } catch (err) {
                    console.error(err);
                    children.innerHTML =
                        '<li class="status-row child-status">Error loading files.</li>';
                }
            }

            function renderFiles(container, objects) {
                container.innerHTML = "";

                if (!objects.length) {
                    const li = document.createElement("li");
                    li.className = "child-item empty";
                    li.textContent = "No files in this folder.";
                    container.appendChild(li);
                    return;
                }

                for (const obj of objects) {
                    const li = document.createElement("li");
                    li.className = "child-item";
                    li.dataset.key = obj.key;

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "select-checkbox";
                    checkbox.dataset.type = "file";
                    checkbox.dataset.key = obj.key;

                    const info = document.createElement("div");
                    info.className = "child-info";

                    const nameWrapper = document.createElement("div");
                    nameWrapper.className = "rename-wrapper";

                    const nameDisplay = document.createElement("span");
                    nameDisplay.className = "name-display";
                    nameDisplay.textContent = obj.name;

                    const nameInput = document.createElement("input");
                    nameInput.type = "text";
                    nameInput.className = "rename-input";
                    nameInput.value = obj.name;
                    nameInput.style.display = "none";

                    nameWrapper.appendChild(nameDisplay);
                    nameWrapper.appendChild(nameInput);

                    const metaEl = document.createElement("div");
                    metaEl.className = "image-meta";
                    const sizeKB = obj.size
                        ? (obj.size / 1024).toFixed(1) + " KB"
                        : "";
                    const when = obj.uploaded
                        ? new Date(obj.uploaded).toLocaleString()
                        : "";
                    const metaParts: string[] = [];
                    if (sizeKB) metaParts.push(sizeKB);
                    if (when) metaParts.push(when);

                    // size and date on separate lines
                    metaEl.innerHTML = metaParts.join("<br>");

                    info.appendChild(nameWrapper);
                    info.appendChild(metaEl);

                    li.appendChild(info);
                    li.appendChild(checkbox);
                    container.appendChild(li);

                    // --- Rename handlers
                    function resetRename() {
                        nameDisplay.style.display = "inline-block";
                        nameInput.style.display = "none";
                    }

                    async function commitRename() {
                        const newName = nameInput.value.trim();
                        if (!newName || newName === obj.name) {
                            resetRename();
                            return;
                        }

                        const folder = obj.key.split("/").slice(0, -1).join("/");
                        const newKey = folder + "/" + newName;

                        const res = await fetch(`${apiBase}/rename`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ oldKey: obj.key, newKey })
                        });

                        if (res.ok) {
                            obj.name = newName;
                            obj.key = newKey;
                            nameDisplay.textContent = newName;
                            alert("Renamed successfully.");
                        } else {
                            alert("Rename failed");
                        }
                        resetRename();
                    }

                    nameDisplay.addEventListener("click", () => {
                        nameDisplay.style.display = "none";
                        nameInput.style.display = "inline-block";
                        nameInput.focus();
                    });

                    nameInput.addEventListener("blur", commitRename);
                    nameInput.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") commitRename();
                        if (e.key === "Escape") resetRename();
                    });

                }
            }

            // search / refresh
            searchEl.addEventListener("input", () => {
                renderProjects();
            });

            refreshEl.addEventListener("click", () => {
                expandedPrefixes.clear();
                loadProjects();
            });

            // folder expand / collapse
            listEl.addEventListener("click", async (event) => {
                const target = event.target;
                if (!target) return;

                const expandBtn = target.closest(".expand-btn");
                if (expandBtn && expandBtn.dataset.prefix) {
                    const prefix = expandBtn.dataset.prefix;
                    const row = expandBtn.closest(".result-item");
                    if (!row) return;
                    await toggleFolder(prefix, row);
                }
            });

            // bulk delete
            bulkDeleteEl.addEventListener("click", async () => {
                /** @type {HTMLInputElement[]} */
                const checked = Array.from(
                    listEl.querySelectorAll(".select-checkbox:checked")
                );

                if (!checked.length) {
                    alert("No items selected.");
                    return;
                }

                const projectPrefixes = [];
                const fileKeys = [];

                for (const input of checked) {
                    if (input.dataset.type === "project" && input.dataset.prefix) {
                        projectPrefixes.push(input.dataset.prefix);
                    } else if (input.dataset.type === "file" && input.dataset.key) {
                        fileKeys.push(input.dataset.key);
                    }
                }

                if (!projectPrefixes.length && !fileKeys.length) {
                    alert("No valid items selected.");
                    return;
                }

                const confirmMsg = [
                    projectPrefixes.length
                        ? `Projects: ${projectPrefixes.length}`
                        : null,
                    fileKeys.length ? `Files: ${fileKeys.length}` : null,
                    "",
                    "This cannot be undone.",
                ]
                    .filter(Boolean)
                    .join("\n");

                if (!confirm(confirmMsg)) return;

                bulkDeleteEl.disabled = true;
                const originalText = bulkDeleteEl.textContent || "Delete selected";
                bulkDeleteEl.textContent = "Deleting…";

                try {
                    // delete projects
                    for (const prefix of projectPrefixes) {
                        try {
                            const res = await fetch(`${apiBase}/delete-project`, {
                                method: "POST",
                                headers: { "content-type": "application/json" },
                                body: JSON.stringify({ prefix }),
                            });
                            if (!res.ok) {
                                console.error("Project delete failed for", prefix, res.status);
                            }
                        } catch (err) {
                            console.error("Project delete error for", prefix, err);
                        }
                    }

                    // delete files
                    for (const key of fileKeys) {
                        try {
                            const res = await fetch(`${apiBase}/delete`, {
                                method: "POST",
                                headers: { "content-type": "application/json" },
                                body: JSON.stringify({ key }),
                            });
                            if (!res.ok) {
                                console.error("File delete failed for", key, res.status);
                            }
                        } catch (err) {
                            console.error("File delete error for", key, err);
                        }
                    }

                    // reload everything so UI matches bucket state
                    expandedPrefixes.clear();
                    await loadProjects();
                    alert("Delete finished. Some failures (if any) are logged in console.");
                } finally {
                    bulkDeleteEl.disabled = false;
                    bulkDeleteEl.textContent = originalText;
                }
            });
            loadProjects();
        });
    </script>
</AdminLayout>
<style>
    .folder-tree,
    .folder-tree ul,
    .folder-tree li {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .admin-title {
        margin: 0 0 8px;
        font-size: clamp(1.6rem, 2.2vw, 1.9rem);
    }

    .admin-subtitle {
        margin: 0 0 20px;
        color: #4b5563;
        font-size: 0.98rem;
    }

    .panel {
        border-radius: 18px;
        border: 1px solid #e5e7eb;
        padding: 16px;
        background: #f9fafb;
        text-align: left;
    }

    .toolbar {
        display: flex;
        gap: 10px;
        margin-bottom: 12px;
        flex-wrap: wrap;
    }

    .toolbar-actions {
        display: flex;
        gap: 8px;
    }

    .search-input {
        flex: 1 1 220px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid #d1d5db;
        font-size: 0.95rem;
    }

    .btn-small {
        padding: 8px 14px;
        border-radius: 999px;
        border: none;
        font-size: 0.9rem;
        background: #111827;
        color: #f9fafb;
        cursor: pointer;
    }

    .btn-small:disabled {
        opacity: 0.6;
        cursor: default;
    }

    .btn-danger {
        border-color: #f97373;
        color: #b91c1c;
        background: #fef2f2;
    }

    .btn-danger:hover:not(:disabled) {
        background: #fee2e2;
    }

    .status-row {
        font-size: 0.85rem;
        color: #6b7280;
        margin-bottom: 10px;
    }

    .results-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
    }

    .result-item {
        border-bottom: 1px solid rgba(15, 23, 42, 0.04);
        padding: 0.5rem 0;
        position: relative;
    }

    .result-title {
        font-size: 0.95rem;
        font-weight: 500;
        color: #111827;
    }

    .result-meta {
        font-size: 0.8rem;
        color: #6b7280;
    }

    .result-actions {
        display: flex;
        gap: 8px;
    }

    .btn-pill {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid #d1d5db;
        font-size: 0.85rem;
        text-decoration: none;
        color: #111827;
        background: #f9fafb;
    }

    .btn-pill:hover {
        background: #e5e7eb;
    }

    .empty {
        font-size: 0.9rem;
        color: #6b7280;
        padding: 8px 2px;
    }

    .result-item.active {
        border-color: #3b82f6;
        background: #eff6ff;
    }
    .item-header {
        display: flex;
        align-items: center;
        gap: 0.35rem;      /* less space between caret + text */
    }

    .select-checkbox {
        margin-left: 0.35rem; /* bring checkbox closer to the label */
        flex-shrink: 0;
    }

    .rename-wrapper {
        position: relative;
        display: inline-block;
        max-width: 100%;
    }

    .name-display {
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: inline-block;
        max-width: 95%;
    }

    .rename-input {
        font-size: inherit;
        padding: 2px 4px;
        border: 1px solid #9ca3af;
        border-radius: 4px;
        width: 95%;
    }

</style>
