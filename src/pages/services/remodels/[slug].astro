---
import MainLayout from "../../../layout/MainLayout.astro";
import "../../../styles/global.css";
import "../../../styles/projects.css";

export const prerender = false;

const { env } = Astro.locals.runtime;
const GALLERY_WORKER = env?.GALLERY_WORKER as Fetcher | undefined;
if (!GALLERY_WORKER) throw new Error("Missing service binding: GALLERY_WORKER");

type Photo = {
    name: string;
    thumb: string;
    full: string;
    description?: string;
};

type ProjectMeta = {
    name?: string;
    description?: string;
};

const { slug } = Astro.params as { slug: string };

let items: Photo[] = [];
let loadError: string | null = null;
let albumName: string = slugToTitle(slug);
let albumDesc: string | undefined;

async function workerFetchJsonWithRetry(binding: any, url: string, tries = 2): Promise<Response | null> {
    let last: Response | null = null;
    for (let i = 0; i < tries; i++) {
        try {
            const req = new Request(url, {
                method: "GET",
                headers: {
                    Accept: "application/json",
                    "Cache-Control": "no-store",
                    Pragma: "no-cache",
                },
                // @ts-expect-error: Cloudflare supports this in Workers
                cf: { cacheTtl: 0, cacheEverything: false },
            });
            const res = await binding.fetch(req);
            last = res;
            const ct = res.headers.get("content-type") || "";
            if (res.ok && ct.includes("application/json")) return res;
        } catch {
            // retry
        }
        await new Promise((r) => setTimeout(r, 150 * (i + 1)));
    }
    return last;
}

try {
    // 1) Primary: remodels-specific request
    const apiItems = new URL(API);
    apiItems.searchParams.set("project", `remodels/${slug}`);

    const r1 = await workerFetchJsonWithRetry(GALLERY_WORKER, apiItems.toString());

    if (!r1 || !r1.ok) {
        if (r1.status !== 404) {
            loadError = `HTTP ${r1.status}`;
        }
    } else if (!r1.headers.get("content-type")?.includes("application/json")) {
        loadError = "Bad response (not JSON)";
    } else {
        const j1 = (await r1.json()) as {
            items?: Photo[];
            project?: ProjectMeta;
        };

        items = j1.items ?? [];
        items.sort((a, b) =>
            a.name.localeCompare(b.name, undefined, {
                numeric: true,
                sensitivity: "base",
            }),
        );

        if (j1.project?.name) albumName = j1.project.name;
        if (j1.project?.description) albumDesc = j1.project.description;
    }

    // 2) If no description yet, pull from remodels album list
    if (!albumDesc) {
        const apiList = new URL(API);
        apiList.searchParams.set("list", "remodels");

        const r2 = await workerFetchJsonWithRetry(GALLERY_WORKER, apiList.toString());
        if (r2 && r2.ok && r2.headers.get("content-type")?.includes("application/json")) {
            const j2 = (await r2.json()) as {
                remodels?: { slug: string; name?: string; description?: string }[];
                projects?: { slug: string; name?: string; description?: string }[];
            };

            const list = j2.remodels ?? j2.projects ?? [];
            const m = list.find((p) => p.slug === slug);

            if (m?.name) albumName = m.name;
            if (m?.description) albumDesc = m.description;
        }
    }

    // 3) Backwards-compat fallback: old ?project=<slug>
    if (!items.length && !loadError) {
        const apiItems2 = new URL(API);
        apiItems2.searchParams.set("project", slug);

        const r3 = await workerFetchJsonWithRetry(GALLERY_WORKER, apiItems2.toString());
        if (r3 && r3.ok && r3.headers.get("content-type")?.includes("application/json")) {
            const j3 = (await r3.json()) as {
                items?: Photo[];
                project?: ProjectMeta;
            };

            items = j3.items ?? [];
            items.sort((a, b) =>
                a.name.localeCompare(b.name, undefined, {
                    numeric: true,
                    sensitivity: "base",
                }),
            );

            if (j3.project?.name) albumName = j3.project.name;
            if (j3.project?.description) albumDesc = j3.project.description;
        }
    }
} catch (e: any) {
    loadError = e?.message ?? "Network error";
}

const cropName = (s: string) =>
    s
        .replace(/\.[^.]+$/, "")        // remove extension
        .replace(/[_]+/g, " ")          // underscores -> spaces
        .replace(/^\s*\d+[\s_-]*/, "")  // strip leading digits + separators
        .replace(/[\s_-]*\d+\s*$/, "")  // strip trailing digits + separators
        .trim();

function slugToTitle(s: string): string {
    return s
        .split("-")
        .filter(Boolean)
        .map((part) => part[0]?.toUpperCase() + part.slice(1))
        .join(" ");
}
const metaDescription =
    albumDesc
        ? `${albumName} – ${albumDesc}`
        : `${albumName} – Remodeling project photos by KIL Construction. Explore before-and-after shots and details from this remodel.`;

---

<MainLayout title={albumName} description={metaDescription} noSticky>
    <h1 class="page-head container">{albumName}</h1>

    {albumDesc && (
        <p class="container muted" style="margin-top:-6px;margin-bottom:14px;">
            {albumDesc}
        </p>
    )}

    <section class="container page-section">
        {items.length > 0 ? (
            <div class="grid grid--projects">
                {items.map((i, index) => {
                    // 1) Base: service/album name in this page
                    const base = albumName;

                    // 2) Start from your existing filename helper(cropName)
                    let cleanedName = cropName ? cropName(i.name) : i.name;

                    // 3) Strip leading IMG_/DSC_ etc.
                    cleanedName = cleanedName.replace(/^(IMG|DSC)[-_]*/i, "").trim();

                    // 4) Prefer item description; fall back to cleaned filename; then to a generic label
                    const sceneLabel =
                        (i.description && i.description.trim()) ||
                        cleanedName ||
                        `project photo ${index + 1}`;

                    const alt = `${base} – ${sceneLabel}`;

                    return (
                        <figure class="card card-media">
                            <a href={i.full || i.thumb} target="_blank" rel="noopener">
                                <img
                                    class="photo"
                                    loading="lazy"
                                    decoding="async"
                                    referrerpolicy="no-referrer"
                                    src={i.thumb || i.full}
                                    srcset={`${(i.thumb || i.full).replace('=s0','=w600')} 600w, ${(i.thumb || i.full).replace('=s0','=w1200')} 1200w, ${(i.thumb || i.full).replace('=s0','=w2000')} 2000w`}
                                    alt={alt}
                                    sizes="(max-width: 560px) 90vw, (max-width: 1200px) 45vw, 28vw"
                                />
                            </a>
                            {(i.description || i.name) && (
                                <figcaption class="caption">
                                    {i.description || cropName(i.name)}
                                </figcaption>
                            )}
                        </figure>
                    );
                })}
            </div>
        ) : (
            !loadError && <p>No images uploaded yet.</p>
        )}

        {loadError && <p class="error">Failed to load: {loadError}</p>}
    </section>
</MainLayout>
